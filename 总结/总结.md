###  第一章

1. JavaScript是一种编程语言，而ECMAScript是这种语言的规范。

2. JavaScript的语法要注意等于号有两种不同用法：
   - 一个单独的等于号（=），用于变量赋值。
   - 三个连续的等于号（===），用于比较两个值。

3. JavaScript有两大语法类别：语句和表达式。
   - 程序其实就是一系列语句的集合；
   - 表达式产生值。他们通常是函数的参数，或是赋值的右边部分。

4. JavaScript变量在声明后使用，而且变量声明和赋值可以同时进行，也可以为一个已有变量进行赋值。标识符是JS中各种语法的名称，而且标识符区分大小写，变量的名字就是一个标识符，对一些标准的全局变量名，同样需要避开。

5. JS有很多值都是我们预期的编程语言的值，他们所有的值都有属性，每一个属性都有一个key和value。原始值包括布尔值、数字、字符串、Null和Undefined。其他的值都是对象。而且所有的非原始值都是对象，简单对象可以通过对象字面量来创建；数组可以通过数组字面量来创建；正则表达式可以通过正则表达式字面量来创建。

6. 大多数编程语言都会有一些值去表示丢失的信息，JS有两个类似的空值undefined和null。前者的意思是没有值，即未被初始化的变量；后者的意思是没有对象，在用到对象的时候，他表示空值。而在JS中使用typeof和instanceof对值进行分类。

7. 原始布尔类型包括true和false两个值。二元逻辑运算符、前置逻辑运算符、比较运算符，这三类运算符会产生布尔值。二元逻辑运算符遵循短路原则，此外，二元逻辑运算符会返回运算数中的一个可能是一个布尔值，也可能不是，对真假的检验，将用于确定返回哪一个。

8. JS中有两种类型的相等，常规的或宽松的相等（或不相等）：==和！=。严格的相等（或不相等）：===和！==。

9. JS中字符串可以直接通过字符串字面量来创建，这些字面量限定在单引号或双引号之内。反斜杠用于转义字符，其产生一些控制字符。字符串可以通过加号进行连接，如果其中一个运算数是字符串的话，则另一个运算数将被转化为字符串。

10. JS中有条件和循环语句两部分。在条件语句中推荐始终使用大括号，他们表示两个或多个语句块，不过，如果从句仅有一个单独的语句是可以不这么做。在循环语句中，有两条语句适用于所有的循环方式，break可以跳离循环；continue会开始一个新的循环迭代。
11. JS中，通常在变量前时用var语句声明变量。一个变量的作用域总是完整的函数。所有变量声明都会被提升，指的是声明会被移动到函数的开始处，而赋值则仍然会在原来的位置进行，而且每个函数都和它周围的变量，保持着连接。

12.  JS中有两种基础的面向对象的机制，即单一对象和构造函数。在单一对象中，以函数作为值的属性，被称为方法。而且如果对方法进行提取，就会失去与对象的连接。所有函数都有其特殊的this变量。如果在方法中有嵌套函数，我们可以采取两种解决方法：1）我们可以将this保存在不同的变量中。2）利用forEach的第二个参数，它可以给this制定一个值。在JS中，用new运算符来调用的话，他们将变成构造函数及对象工厂。在构造函数中，有两部分，第一部分为point函数设置实例数据，而第二部分为point prototype属性包含一个带有方法的对象。

13. 在JS中，数组是一些有序的元素，可以通过证书索引，从零开始被访问。在这里我们需要了解数组字面量，数组方法以及遍历数组。



### 第二章

1. ECMAScript语言中所有的值都有一个对应的语言类型，语言类型包括Undefined、Null、Boolean、String、Number和Object。

2. JavaScript有七种内置类型：空值（null）、未定义（undefined）、布尔值（boolean）、数字（number）、字符串（string）、对象（object）、符号（symbol。ES6中新增）。

​       例： typeof  Symbol（）===”symbol”; //true

​                typeof  null===”object”; //true

3. Null是基本类型中唯一的一个“假值”，检测null值的类型：使用复合条件

​         var a = null;

​         (!a && typeof a ===”object”);//true 

4.  函数function是javascript的一个内置类型，实际上是object的一个“子类型”，函数是“可调用对象”，内部属性[[Call]]使其可以被调用。函数对象的length属性是其声明的参数的个数。

5. 数组也是object的一个“子类型”，数组的元素按数字顺序来进行索引，其length属性是元素的个数。

6. Javascript中变量没有类型，只有值才有类型，变量可以随时持有任何类型的值。对变量执行typeof操作时，得到的结果是变量持有的值的类型。

7. 变量在未持有值的时候为undefined，即已在作用域中声明但还没有赋值的变量；还没有在作用域中声明过的变量，是undeclared。

   - typeof对undeclared变量的处理方式：typeof b；//“undefined”

   - typeof  b；没有报错，是因为typeof有一个特殊的安全防范机制，该安全防范机制对在浏览器中运行的javascript代码来说是很有帮助的，因为多个脚本文件会在共享的全局命名空间中加载变量。

8. 数组可以容纳任何类型的值，可以是字符串，对象或其他数组（多维数组）；对数组声明后即可向其中加入值，不需要预先设定大小；delete运算符可以将单元从数组中删除，单元删除后，数组的length属性不会发生变化。

9. 创建稀疏数组时，a[1];//undefined  与a[1]=undefined;不同。

10. 数组通过数字进行索引，也可以包含字符串键值和属性，但是建议使用对象来存放键值/属性值，用对象来存放数字索引值。

11. 类数组转换为真正数组，一般通过数组工具函数（indexOf（），concat（），forEach（））实现。ES6中的内置工具Array.from（）也能实现相同功能。

12. 字符串和数组都是类数组，都有length属性以及indexOf（）和concat（）方法。

13. Javascript中字符串是不可变的，而数组是可变的。字符串的不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串，而数组的成员函数都是在其原始值上进行操作。

14. JavaScript中整数没有小数的十进制数，42.0等同于42。Javascript使用的是“双精度”格式。

15. 数字的语法：数字前面的0可以省略，小数点后小数部分的0也可以省略；特别大和特别小的数字默认用指数格式显示，与toExponential（）函数的输出结果相同。
16. 数字值可以使用Number对象进行封装，因此数字值可以调用Number.prototype中的方法。toFixed（显示小数位数）方法可指定小数部分的显示位数；toPrecision（位数）方法指定有效数位的显示位数。Eg：42.toFixed（3）；无效语法，点·被视为常量42.的一部分，在 42与点·之间加一个空格，该语句有效。

17. 较小的数值：0.1+0.2===0.3//false，浮点数中0.1和0.2并不是十分精确。判断0.1+0.2和0.3是否相等，设置一个误差范围值，这个值通常是2^-52，ES6之后，这个值定义在Number.EPSILON中，可以直接用。

18. 最大的浮点数大约是1.789e+308，定义在Number.MAX_VALUE中；最小的浮点数定义在Number.MIN_VALUE中，大约是5e-324，不是负数，但无限接近于0！

    最大整数是2^53-1，在ES6中被定义为Number.MAX_SAFE_INTEGER；最小整数在ES6中被定义为Number.MIN_SAFE_INTEGER。

19. 整数检测：ES6中Number.isInteger（）方法

20. 数位运算符|只适用于32位整数，a | θ可以将变量a中的数值转换为32位有符号整数。

21. Undefined和null的异同：undefined类型只有一个值，即undefined，null类型也只有一个值，即null，他们的名称既是类型也是值。Null指空值，是曾赋过值，但是目前没有值，undefined指没有值，从未赋值。Null是一个特殊关键字，不是标识符，我们不能将其作为变量来使用和赋值，但undefined却是一个标识符，可以被当做变量来使用和赋值。

22.  Void运算符，通过void运算符可以得到undefined，void并不改变表达式的结果，只是让表达式不返回值。

23.  NaN不是一个数字，仍是数字类型，他与自身不相等。isNaN（）判断是否是NaN。“foo”不是一个数字，但也不是NaN，但是window.isNaN（“foo”）；返回true。ES6之后，Number.isNaN（“foo”）；返回false。

24.  JavaScript的运算结果有可能溢出，此时结果为Infinity或者-Infinity。Infinity是一个未定义的操作，结果为NaN.

25. （-0）转换为字符串为“0”，“-0”转换为数字为-0.零的比较：0==-0；0===-0

26. ES6中新加入Object.is（a，b）来判断两个值是否绝对相等。

27.  Javascript引用指向的是值，如果一个值有10个引用，这些引用指向的都是同一个值，他们相互之间没有引用/指向关系。

28. 基本类型值总是通过值复制的方法来赋值/传递；引用数据类型总是通过引用复制的方来赋值/传递。引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向。

29.  如果通过值复制的方式来传递数组，就需要为其创建一个复本，这样传递的就不再是原始值eg：foo（a.slice（））；slice（）不带参数会返回当前数组的一个浅复本。由于传递给参数的是指向该复本的引用，所以不会影响a指向的数组。

30. 类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的的运行时。

31. toString，负责处理非字符串的强制类型转换，var a=[1,2,3];a.toString();//”1,2,3”。

32. JSON.stringify（）在对象中遇到undefined、function和symbol时会自动将其hulue，在数组中则会返回null。对包含循环引用的对象执行JSON.stringify（）会出错。

33. 向JSON.stringify（）传递一个可选参数replacer，他可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除。如果是一个数组，则必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略；如果是一个函数，他会对对象本身调用一次，然后对对象中的每个属性个调用一次，每次传递两个参数，键和值，如果要忽略某个键就返回undefined，否则返回指定的值。

34. ToNumber，将非数字值当做数字来使用，true为1，false为0，undefined为NaN，null为0。



### 第三章

1. JS不区分整数值和浮点数值，js程序中用一个数字序列表示一个十进制整数。

2. 算术运算：除基本的运算外，js还支持更加复杂的算术运算，这些复杂运算通过作为Math对象的属性定义的函数和常量来实现。

3. Js中的算术运算在溢出，下溢或被零整除时不会报错。

4.  在编程语言的语义和类型体系环境中，静态一般是有边意识或者非运行时，动态指的是运行时。在静态类型语言中，变量参数和对象成员都有编译系边一时能识别的类型，即使在动态类型语言中，变量依然有一个动态的类型，是指在执行的某一时刻变量值的类型。

5. 在JS中，处理类型不适配的情况，最主要的方法是将它强制转化为正确的类型，强制转化意味着隐式的类型转换。Js，内置的转换机制只支持布尔值数字字符串和对象，没有标准的方法，将某个构造函数的实例转换为另一个构造函数的实例。

6. JS中原始值包括布尔值、数字、字符串、null和undefined。其他的直都是对象。两者之间最主要的区别是类别力是如何互相比较的。每一个对象有唯一的标识符，并且只和自身相等。

7.  所有的非原始值都是对象长线的对象有简单对象、数组、正则表达式。简单对象可以通过对对象字面量来创建；数组可以通过数组字面量来创建；正则表达式可以通过，正则表达式字面量来创建。而对象有按引用进行比较，默认可便、用户可拓展的特点。

8.  u n d e f  i n e d表示删除1个对象属性或者数组元素，而 Nul l 表示将属性或者元素设置为空。Null是圆形恋爱最顶端的元素，当字符串中没有匹配到，正则表达式的结果时，Regexp.prototype.exec（）会返回null。在对检测undefined和null，可通过严格相等检测null；通过严格相等（===）检测undefined，也可以通过typeof运算符检测undefined。Undefined应该具有指向性，因为它表达的不仅仅是一个对象，并且强制转换不应该为零，因为这会使错误难以发现，所以它被作为另一个空值。

9. 布尔值数字字符串这三种原始值都有相应的构造函数boolean，number，String。作为构造函数，他们创建的对象和他们包装的原始值有很大的不同；作为函数，他们会将值转化为相应的原式值。

10. 强制类型转化，指的是只从一种类型隐式的转换成另外一种类型。而强制类型转换会隐藏bug。



### 第四章

1. 所有的运算符都会强制要求他们的运算数为合适的类型，大部分运算符只对原始值有效。但是在js中，她会先将数组转化成字符串，然后再把它们拼接起来。

2. 普通的赋值运算有多种使用方法；复合赋值运算符被写成OP=的形式，其中OP是一种二元运算符，=是赋值运算符。复合赋值运算符有算数运算符、位运算符、字符拼接。

3. Js中有两种方式来判断两个值是否相等，严格相等和不严格相等要求比较的值必须是相同的类型，普通相等和不等会先尝试将两个不同类型的值进行转换，再使用严格相等进行比较。

4. 不同类型的值总是严格不等的，如果两个值的类型相等，我们将进行查看是否为undefined===Undefined的比较、是否为null===null的比较、比较两个数字。在比较两个布尔值两个字符串，结果显而易见，但是在比较两个对象，当且仅当x和y是同一个对象时，x===y；如果比较两个不同的对象，则需要自己实现一个比较算法。

5. 普通相等的比较算法原理：如果两个运算数的类型相同，则使用严格相等比较它们。这里需要了解三个陷阱：宽松相当于不玩转换不同宽松相等中的字符串，宽松相等中的对象。

6. 在JS中有以下几种排序运算符：小于号，小于等于号，大于号，大于号，大于号。

7. 布尔运算符，数字运算符只会有一种类型的晕算术，并且只返回该类型的运算结果。布尔运算符有二元逻辑运算符和逻辑非，数字运算有算术运算符和位运算符。

8. 特殊运算符即条件、逗号和为void运算符。Void，运算符的用处有：1）Void 0等同于undefined。2）避免表达式返回结果。3）用做IIFE的前缀。4）为什么会有void运算符。

9. typeof 运算符能区分原始值和对象，并检测出原始值的类型，但是这个运算符的结果不是完全的符合逻辑，只能大概的符合ECMAscript规范中定义的类型。Instanceof可以检测仪个对象是否是特定构造函数的一个实例。

10. var用来声明变量，可以用它来创建变量并使用变量，其中等号运算符位用来给变量赋值。

11.  可以在循环中使用var声明变量，但是变量的作用域永远是当前包含循环的函数体，在遍历属性时，属性可以被删除。

### 第五章

1.  函数是可以被调用的，值一种定义函数的方式叫做函数声明。在jc中函数的三种形式有函数声明，函数表达式、构造函数。

2.  区分术语形参和实参的准则：形参备用在定义函数时，但是石参在函数调用时经常被使用。

3. 创建函数的三种方式：一、通过函数表达式，二、通过函数声明，三、通过function（）构造器。函数表达式会产生一个值机函数对象；函数声明定义了一个新的变量，创建了一个函数对象，并将函数对象赋值给这个新的变量；而Function构造器执行传给他的jc代码字符串。

4. 函数提升表示将函数的声明放到作用域的开始，函数声明式做了完全提升的，而变量声明则是部分提升的。对于函数的名称，大多数的JSy引擎都会对函数对象提供一个非标准的name属性。

5. 函数声明，等价var声明+函数表达式两种效果基本是一样的。但是函数声明相比函数表达式有两个优势，一、函数声明会做代码提升，因此可以在源代码中鲜于函数的定义来调用函数，二、他们具有名字，不过JS引擎也在对匿名函数表达式的名字引用做优化。

6. Arguments具有以下特征：一、他是类数组的，但又非数组，一方面他有一个length属性，所有的参数都可以通过索引值来进行读写，另一方面arguments不是一个数组，他仅仅是类似。二、他是一个对象，因此他支持所有的对象方法和操作。

7. 在js严格模式中，禁用了arguments的一些非常用特性：Arguments.Callee，指向了当前调用的函数。在非严格模式中，当你改变了一个参数arguments会实时的变化。

8. 在判断一个参数是否缺失，使我们有三种方式，第一种可以检测它的值是否为undefined，第二种可以将参数转化为布尔值，第三种可以用arguments.length数量的最小值。

9. 以上最后一种方式相比前两种的区别：前两种方式无法区分foo（）和foo（undefined）。他们对于两种情况会抛一样的错误。第三种方式会对foo（）抛错，而对于foo（Undefined）会正常使用undefined传入函数并调用。

10. 当如果参数是可选的，这意味着当你没有指定这个参数，他将会使用默认值类似于强制性参数，我们有四种处理可选参数的方法：第一种检测undefined，；第二种将可选参数转化为布尔值；第三种可以使用或运算符，如果左侧操作数不是false，返回左侧的操作数，否则将返回右侧的操作数；第四种可以使用arguments.length来检测函数支持的最小数量的参数。

11. 以上最后一种方式与其他方式的区别：一、前三种方式无法区分bar（1，2，undefined）。二、第四种方式对于bar（1，2）会使用默认值，而对于bar（1，2，Undefined）会保留undefined的传入。

12. 在编程语言中，调用函数或者方式是可以将实参和形参做映射通常的两种方法有：一、通过位置来映射的位置型参数，二、具名参数则通过名称来做变量的映射。

 ### 第六章

1. 我们可以从静态性（词法性）和动态性来看一个程序。静态性：可以无需执行程序，而只从程序源码的角度来看程序的工作；动态性：表示一个程序在运行，七所表现出来的特性。

2. 变量的作用域，是指变量在何处可以被访问到。

3. 词法作用域，JS中的变量都有词法作用域的，因此一个程序的静态结构，决定了一个变量的作用域。

4. 嵌套作用域，如果在一个变量的直接作用域中，嵌套有多个作用域，那么这个变量在所有的这些作用狱中都可以被访问。

5. 覆盖，如果一个作用域中声明了一个与外层作用域同名的变量，那么在这个内部作用域以及其内部的所有作用狱中将会访问不到外面的变量。

6. 关于iife，我们需要注意：一、他是立即执行的；二、他必须是一个表达式；三、别忘了后面的分号。

7. 关于iife，其他使用场景有：一、避免全局变量，隐藏全局作用域的变量；二、创建新的环境，避免共享；三、保持全局的数据，对于构造器的数据相对独立；四、将全局数据附加到单列对象上；五、将全局数据附加到方法中

8. 浏览器和node.js都有一些全局的变量，可以引用全局的对象。但是他们也有不同：一、浏览器中的全局对象是window，它是文档对象模型的一部分，而非ecmascript 5的一部分。每一个真或者window中都有一个全局对象。nodejs中的全局对象是global，它是其一个专属变量，每一个模块都有它自己的作用，御在这些作用狱中this致向了这个作用域的对象。

9. Window使用场景：一、创建全局变量；二、内部插件；三、风险检查器；四、检测一个全局变量是否存在；五、在全局作用域中创建内容。

10. 对于词法和动态这两个维度，动态维度是执行上下文的栈；词法维度是环境链。

    ------------------------------------------------------------------------------------------------------------------------

11.  声明提升是在代码真正运行之前，所有变量开辟空间，存储在内存中，所有的变量声明和函数声明提升到当前作用域的最前面。 

12.  声明提升的规则：

    - 函数声明整体提前
    - 变量声明提前赋值留在原地
    - 函数会首先被提升，然后才是变量，
    - 函数声明有冲突会覆盖，变量声明有冲突会忽略(忽略变量声明，直接赋值)。 

13.   Js编译和执行是一个不断交替的过程，全局编译阶段预解析，全局顺序执行阶段变量赋值，函数调用等操作，当遇到函数调用时，在执行函数内代码时进行函数范围内的编译，当存在函数嵌套时，以此类推会进行多次函数预解析 。

14.   浏览器中的全局上下文的变量，对象是window对象，在页面关闭前一直存在。 

15.   作用域是一套关于如何存储变量当中的值，并且能在之后对这个值进行访问和修改的规则，

16.  作用域的作用：作用域指定变量与函数的可访问范围，作用域控制着变量与函数的可变见性

17.   作用域分为全局作用域，局部作用域，块作用域 

     - 全局作用域，在全局作用域下声明的变量叫做全局变量，全局变量在全局下都可以使用，全局作用域中无法访问到局部作用域中的变量 
     -  全局变量的创建方式：
       1. 在全局作用域下var声明的变量
       2. 在函数内部没有使用var关键字声明直接赋值的变量
       3. 使用window全局对象创建的属性和方法 
     -  函数作用域，在函数作用域下声明的变量叫局部变量，局部变量只在当前函数内部中使用，局部作用域可以访问到全局作用域中的变量 
     -  局部变量的创建方式：
       1. 在函数内部通过var声名的变量
       2. 函数的形参。 
     -  块作用于任何一对花括号中的语句级都属于一个框块，在这之中定义的所有变量，在代码外都是不可见的，我们称之为块作用域。 

18. 作用域的模型有两种主要的工作模型 

    -  词法作用域静态性，是由函数定义的书写位置决定，与调用位置无关
    - 动态作用与动态性，由调用位置决定，不关心变量和函数定义和书写的位置。 

19.   JS作用域是词法，作用域，词法作用域具有静态性，静态结构决定了一个变量的作用域，通过new Function创建的函数对象不遵从静态词法作用域，它总是在全局作用于下执行(父级是全局作用域)。

20.   [[scope]]是虚拟属性无法访问和修改。是函数创建时生成的属性，保存着这个函数所有父级执行上下文环境中变量对象的集合。 

21.  作用域链由当前执行环境与所有父级执行环境的一系列变量组成。ScopeChain=VO(本地变量对象)+[[scope]] 

22.  作用域链的作用，提供对变量和函数访问的权限和顺序的规则。 

23.  变量函数访问规则：沿着作用域链从里向外查找，查找会在找到第一个匹配的标识符时停止，查找只会找到一级标识符(只会找到对象，本身不会找到对象中的属性)。

24.   内存空间管理：分配内存，使用分配到的内存，不需要是释放内存。 

25.  垃圾回收机制，当一个值失去引用之后就会回收，当一个函数执行上下文运行完毕后，内部的所有内容就会失去引用被垃圾回收机制回收，但是一个函数的执行上下文运行完毕后，内部的内容仍然被引用着，就不会被回收。 

    ---------------------------------------------------------------------------------------------------------------------------------------

### 第七章

---

1.  闭包是由函数以及创建该函数的词法环境组合而成，这个环境包含了这个闭包创建时所需访问的所有局部变量。 

2.  闭包的作用：可通过闭包访问函数作用域内的局部变量，使函数中的变量被保存在内存中，不被释放。 

    闭包的缺点：由于闭包会是使函数中的变量，都被保存在内存中，内存消耗大，闭包会在父函数外部改变父函数内部变量的值。 

3.  闭包的应用IIFE解决了变量共享变量污染的问题(加一个函数作用域)。 

4.  闭包的常见形式：以普通函数形式返回；作为对象的方法返回。 

5.  this是被自动定义在所有函数的作用域中的一个关键字，this是在函数运行期间绑定,与函数定义无关。 

    this的作用：复用代码，为函数自动引用合适的上下文对象，提供了一个更加优雅而简便的方式来隐式传递一个对象引用。 

6.  this绑定规则:

   - 作为函数直接调用-->默认绑定

      函数嵌套时需要this不进行作用域传递。
      函数嵌套时this绑定： 变量that _this self 锁定this；bind()锁定 

   - 作为对象方法调用-->隐式绑定

      调用位置是否有上下文对象函数 

      作为对象的方法调用时，函数上下文指向这个对象

      数组中存放函数被数组索引调用，this上下文指向这个数组 

   - 作为构造函数调用-->new绑定

   - 通过call/apply间接调用-->显示绑定。 

   -  绑定优先级：new绑定>显示绑定>隐式绑定>默认绑定。 

7.  严格模式是采用具有限制性js变体的一种方式，严格模式可以应用到整个脚本或个别函数中。 

8.  开启严格模式

   - 整个脚本文件，开启严格模式，需要在所有语句前放一个特定语句“use strict”;
   - 某个函数开启严格模式,“use strict”声明放在函数体所有语句之前。 

9.  普通模式下

   - 如果一个变量没有声明就赋值，默认是全局变量
   - 在全局作用域函数中的 this指向window对象
   - 构造函数不加new，也可以调用,this指向全局对象。 

    严格模式下

   - 变量必须先声明再使用
   - 全局作用域中函数中的this是undefined
   - 构造函数不加new调用this报错。 

10.  函数形式分为纯函数，高阶函数，回调函数。

    -  纯函数一个函数的输出不受外部环境影响，同时也不影响外部环境，相同的输入得到相同的输出，不会产生副作用。 
    -  高阶函数是对其他函数进行操作的函数。
      实现方法：函数的参数为函数，函数的返回值为函数。
      在封装一个函数时，对于不确定的变量用传递参数的方式来指定，对于不确定的过程用向函数中传入另一个函数来指定。
    -   回调函数一个函数被作为参数传递给另一个函数，回调函数并不会马上被执行。 

    ---

    
    
    1. JavaScript是一门编译语言。但它与传统的编译语言不同，他不是提前编译的，编译结果也不能在分布式系统中进行移植。
    
    2. 将由字符组成的字符串分解成有意义的代码块，这些代码快被称为词法单元。空格是否会被当做词法单元，取决于空格在这门语言中是否具有意义。
    
    3. 分词和词法分析，主要差异在于词法单元的识别，是通过有状态还是无状态的方式进行的。有状态就是词法分析无状态就是分词。
    
    4. 解析/语法分析。这个过程是将语法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的数。这个数被称为抽象语法树。
    
    5. 将AST转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。
    
    6. 引擎是从头到尾负责整个JavaScript程序的编译及执行过程。
    
    7. 编译器 负责语法分析及代码生成。
    
    8. 作用域 负责收集并维护有所有声明的标识符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码，对这些标识符的访问权限。
    
    9. 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
    
    10. 当一个块或函数嵌套在另一个块或函数中时。就发生了作用域的嵌套。因此在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量或抵达最外层的作用域为止。
    
    11. 便利嵌套作用，域链的规则引擎，从当前的执行作用域开始查找变量，如果找不到就向上一级继续查找，当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。
    
    12. 作用域是一套规则用于规定在何处，以及如何查找变量，如果查找的目的是对变量进行赋值，那么就会使用LHS查询，如果目的是获取变量的值，就会使用RHS查询。
    
    13. 作用于气泡，由其对应的作用越快，代码写在哪里决定。他们是逐级包括的。
    
    14. 没有任何函数的气泡可以同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分的同时出现在两个父极函数中一样。
    
    15. 作用与气泡的结构和互相之间的位置关系，给引擎提供了足够的位置信息引擎用这些信息来查找标识符的位置。
    
    16. 作用域查找会在找到第1个匹配的标识符时停止。
    
    17. 在多层的嵌套作用域中，可以定义同名的标识符，这叫做遮蔽效应，抛开遮蔽效应，作用于查找始终，从运行时所处的内内部作用域开始，逐级向外或者说向上进行，直到遇到第1个匹配的标识符为止。
    
    18. 全局变量会自动成为全局对象的属性，因此可以不直接通过全局对象的语法名称，而是间接的通过对全局对象属性的引用来对其进行访问。
    
    19. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只有函数被声明时所处的位置决定。
    
    20. with通常被当做重复引用同一个对象时的多个属性的快捷方式，可以不需要重复引用对象本身。
    
    21. with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标示符。
    
    22. 词法作用域意味着作用域是由书写代码时，函数声明的位置来决定的，编译的词法分析阶段，基本能够知道全部标识符在哪里，以及是如何声明的，如从而能够预测在执行过程中如何对他们进行查找。
    
    23. JavaScript中有两个机制可以“欺骗”词法作用域:eval(..)和with。前者可以对一段包含一个或多个声明的代码字符串进行演算，并借此来修改已经存在的词法作用域。后者本质上是通过将一个对象的引用当做作用域来处理，将对象的属性当作作用域的标识符来处理，从而创建了一个新的词法作用域。
    
    24. 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因此为引擎，只能谨慎的认为这样的优化是无效的使用，这其中任何一个机制都将导致代码运行变慢。
    
    25. 函数作用域的含义是指属于这个函数的全部变量，都可以在整个函数的范围内使用及复用。这种设计方案是非常有用的，能充分利用JavaScript变量可以根据需要改变之类型的动态特性。
    
    26. 有很多原因促成了这种基于作用域的隐藏方法。他们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中应该最小限度的暴露必要内容，而将其他内容都隐藏起来。
    
    27. 这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用中，当然可以在所有的内部嵌套作用狱中访问他们。但这样会破坏前面提到的最小特权原则，因为可能会暴露太多过多的变量或函数。而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。
    
    28. 隐蔽作用域中的变量和函数所带来的另一个好处是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字，但用途却不一样，无意间可能造成命名冲突，冲突会导致变量的值被意外覆盖。
    
    29. 这些库通常会在全局作用域装生命量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象的属性，而不是将自己的标识符暴露在顶级的语法作用域中。
    
    30. 另一种规避冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无法无需将标识符加入到全局作用域中，而是通过依赖管理器的机制，将库的标识符显示的导入到另外一个特定的作用域中。
    
    31. 这些工具并没有能够违反司法作用与规则的神奇功能。他们只是利用作用域的规则，强制所有标识符都不能注入到共享作用域中，而是保持在私有无冲突的作用域中，这样可以有效规避掉所有的意外冲突。因此即使不使用任何依赖管理工具，也可以实现相同的功效。
    
    32. (function  foo(){..})作为函数表达式意味着foo只能在..在所代表的位置中被访问，外部作用域则不行。 foo变量名被隐藏在自身中意味着不会非必要的污染外部作用域。
    
    33. 匿名函数表达式的缺点：
    
    （1）一名函数在战追踪中不会显示出有意义的函数名，使得调试很困难。
    
    （2）如果没有函数名，当函数需要引用自身史，只能使用已经过期的aryuments.callee引用。
    
    （3）匿名函数省略了，对于代码可读性可理解性很重要的函数名，一个描述性的名称可以让代码不言自明。
    
    34. IIFE最常见的用法是使用一个匿名函数表达式。
    
    35. let关键字可以将变量绑定到所在的任意作用域中。
    
    36. 先有声明后有赋值。
    
    37. 只有说明本身会被提升而赋值或其他运行逻辑，会在会留在原地。如果提升改变了代码执行的顺序会造成非常严重的破坏。
    
    38. 每个作用域都会进行提升操作。尽管前面大部分的代码片段已经简化了。
    
    39. 函数声明和变量声明都会被提升，但值得注意的细节是函数会首先被提升，然后才是变量。
    
    40. 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。
    
    41. 闭包是基于词法作用与书写代码时所产生的自然结果，你甚至不需要为了他利用他们而有意识的创建闭包，闭包的创建和使用在你的代码中随处可见，你缺少的是根据你自己的意愿来识别拥抱和影响闭包的思维环境。
    
    42. 无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。
    
    43. 模块模式需要具备两个必要条件。
    
    44. 必须有外部的封闭函数，该函数必须至少被调用一次。
    
    45. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。
    
    46. 一个具有函数属性的对象，本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象，并不是真正的模块。
    
    47. 通过在模块实例的内部保留，对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改他们的值。
    
    48. 大多数木块依赖加载器或管理器，本质上都是将这种模块定义封装进一个友好的API。
    
    49. 模块就是模块，即使在它们外层加上一个友好的包装工具，也不会发生任何变化。
    
    50. 基于函数的模块并不是一个能被稳定识别的模式，他们的API语义只有在运行时才会被考虑进来，因此可以在运行时修改一个模块的API。
    
    51.  Es6的模块没有行内格式，必须被定义在独立的文件中。浏览器或引擎有一个默认的模块加载器，可以在导入模块时异步的加载模块文件。
    
    52. 模块文件中的内容会被当做好像包含在作用域闭包中的一样来处理，就和前面介绍的函数闭包模块一样。
    
    53. 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。
    
    54. 如果没能认出闭包，也不了解他的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以在可以用多种形式来实现模块的模式。
    
     

### 第八章 第九章

1. 一个对象中的某一项称为属性，属性有三种：一数据属性，二访问器属性，三内置属性。数据属性是对象中的普通属性，包括方法；访问气势类似于读写属性的特殊方法；内置属性只存在于es语言规范中。
2. 中括号操作符有以下作用：可以获取属性、调用方设置属性、删除属性。
3. 当你调用一个函数时，this可以作为模宽松模式中的普通函数和严格模式中普通构造函数手动模拟apply（）的步骤：第一步，通过方法调用把参数传给date；第二步，使用apply（）法术祖传给bind（）。函数和方法的隐式参数。
4. 关于proto，我们需要了解以下几点： proto不属于ES5标准，因此如果希望代码遵循这个标准，且在当前的js引擎中稳定运行，那么就不能使用它；越来越多的引擎开始支持__proto，而它也将成为es6的一部分；可以用表达式检测引擎是否支持特殊属性  proto。
5. 遍历和检测属性的相关操作，show继承和枚举的影响。可以列出自有的属性剑，也可以列出所有的可枚举的属性键，并检查这个属性是否存在。

---

1.  构造函数的定义与调用:
   - 构造函数的首字母，必须大写用来区分普通函数
   - 内部使用的this对象调用时，指向即将要生成的实例对象
   - 使用new运算符调用 
2.  构造函数实例化即创建一个实例对象分配内存，执行构造函数即对分配的内存空间进行初始化。 
3.  构造函数的返回值:
   - 没有return语句返回this及实例对象;
   - 有return语句返回值，且返回值为基本数据类型，构造函数会忽略返回的值，依然返回this对象
   - 有return语句且返回值为引用数据类型构造函数会返回return值。 
4.  Prototype属性：
   - 使用者：只有函数才会有Prototype属性,
   - 创建者：只要创建一个函数js引擎，会根据一组特定的规则为该函数创建一个对象并初始化一个属性 constructor用来引用该函数。
   -  作用：我们通可以通过Prototype属性向对象添加属性和方法  
5.  每个实例对象都有一个属性__proto__指向它的构造函数的原型对象。 
6.  原型对象可以看作公共容器,定义在原型对象上的属性，会让他的所有实例对象都共享这个属性，但是不会在每个实例的内部重新定义这个方法，内存占用比较小。
7.  实例对象可以访问本身对象上的实例属性也可以访问原型对象上的圆形属性，但是不能访问构造函数上的静态属性，静态属性只能通过构造函数来访问。
8.  new运算符的作用
   - 创建一个空的简单的js对象，
   - 该对象会被执行 [[prototype]]连接，
   - 将该对象作为this的上下文并执行构造函数中的代码，
   - 如果构造函数没有返回引用类型，则返回this指向的实例对象。 

---

---

1.  对象是一种复合值，将很多值复合在一起，对象是若干无需属性的集合，可以直接通过属性名来访问对象的属性。 

2.  对象的重要性，一切数据都是通过变量标识符保存对象，将相应的数据封装在一起统一管理。 

3.  属性的重要性操作数据就是操作对象的属性。 

4.  对象根据谁来创建来区分:

   - 内置对象
     -  构造器函数对象
     - 非构造器函数对象。 
   - 宿主对象
   - 自定义对象。

5.   属性分为数据属性，访问器属性，内置属性。

   数据属性是对象中的不同属性，从字符串的键到值的映射，是最常见的属性类型

   访问器属性类似于读写属性的特殊方法访问，其可以计算属性的值

   内置属性只存在于ES语言规范中，不能直接访问，有可能存在间接访问方式，规定将内置属性的键，置于方括号中 

6.  数据属性的特性

   - 属性的值value
   - 可写特性writable
   - 可配置特性configurable
   - 可枚举特性enumerable。 

7.  属性特性描述是一个用来查看对象属性的特性的对象，该对象包含了4个属性对应4个特征，封装了属性特征的对象，方便实现数据属性特性的设置和查询。 

8.  设置属性
   Object.defineProperty()
   Object.defineProperties()
   查询属性
   Object.getOwnPropertyDescriptor()
   Object.getOwnPropertyDescriptors() 

9.  枚举性一般来说系统创建的属性不可枚举而应付创建的属性可没举，没举的主要目的是判断for in循环中的哪些属性应该被忽略。 

10.  定义属性，如果属性不存在，会创建一个新的属性，它的特性有描述符指定如果未指定则使用默认值，如果属性已经存在，会更新描述符指定的属性特性，但是描述符中的特性没有对应的特性的特性不变。 

11.  访问器属性的特性：

    get读取属性时的调用的函数，该函数计算读取的结果默认是undefined.

    set设置属性值时调用的函数,该函数接受设置的值作为参数，默认是undefined。

12.  设置访问器属性特性，定义一个或两个和属性同名的函数，没有使用function关键字，而是使用get和set。属性名和函数体没有冒号分隔；函数体结束和下一个属性有逗号分割；js把这些函数当作对象的方法调用函数中this指向这个对象。 

---



### 第十章 第十一章

---

1.  属性访问机制：实例对象继承原型，对象的属性即可访问原型对象上的属性构造函数与原型方法中的this指向，调用该方法的对象，当通过对象访问属性时，js首先从本对象查找，接着是它的原型以及原型的原型。 

2.  继承：属性的继承只发生在读属性，而在写属性时不会发生。读属性时，js首先从本对象查找接着是它的原型，直到原型链的顶端，可以访问原型链上的任何一个属性，就好像对象本身拥有这个属性一样。 

3.  属性分类：

   自有属性：是指直接赋予该对象的属性，不需要从原型链上进行查找的属性 

   继承属性：是从原型链上查找的属性。 

4.  检测属性
   obj.hasOwnProperty(prop)返回一个布尔值，判断对象自有属性中是否具有指定的属性
   Object.getOwnPropertyNames(obj)返回一个由指定对象的所有自身属性的属性名，包括不可枚举属性组成的数组。 

   prop in obj 检查obj包含它的原型链，是否包含具有指定名称的属性的对象，如果有则返回处。 

5.  所有对象具有proto属性没有prototype属性，函数具有prototype属性也具有proto属性,Function.prototype，虽然是函数，但是不具有prototype属性。 

6.  Object.create(proto)创建一个新对象，使用现有的对象来提供新对象的__proto__ 

7.  数据类型检测typeof,constructor,instanceof toString 

8.  对象的constructor属性用于返回创建该对象的函数，也就是我们常说的构造函数

---

---

1.  把方法写在构造函数内的情况，我们简称为函数内方法，把方法写在prototype属性上的情况，我们简称为prototype以上的方法 

2.  函数内方法定义在构造函数内部的方法，会在它的每个实例对象上都克隆这个方法，内存占用比较大，但可以访问函数内部的私有变量, Prototype上的方法定义在构造函数的prototype属性上的方法，会让他的所有实际对象都共享这个方法，但是不会在每个实例对象内部重新定义这个方法，内存占用比较小，但是不可以访问函数内部的私有变量 。

3.  一个方法重复调用自身的情况叫做递归递归，一定要有一个条件来结束递归，否则将陷入无限的循环 

4.  浅拷贝：拷贝基本类型的值，拷贝引用类型的引用地址

    深拷贝拷贝基本类型的纸拷贝，引用类型是数组或对象使用递归把父对象中所有属于类型引用类型的对象都遍历赋予给子对象即可 

5.  深拷贝和浅拷贝最根本的区别在于是否真正获取了一个对象的复制实体，而不是引用 

6.  深拷贝的缺点，虽然深拷贝能够避免前拷贝出现的问题，但是却会带来性能上的问题，如果一个对象非常复杂或数据庞大，性能消耗也会增加 

7.  使用拷贝的原因，我们希望再改变新的数组的时候不改变原数组 

8.  proto不是一个规范或标准属性，但是在部分浏览器实现了此属性 

9.  原型继承将子级的原型对象设置为父级的一个实例。

   优点：实例是子级的实例也是父级的实力，父级新增原型方法，属性值子级都能访问到

   缺点：所有的实例都会共用一个原型链，如果通过实例修改原形属性，那么所有实例访问的值都会被修改 

10.  构造继承通过call /apply方法，可以在自己构造函数上执行父级构造函数

     优点：直接继承父级构造函数中的属性和方法

     缺点：构造函数的继承，相当于将父级复制给子级，在子级中实现了所有父级的方法，影响自己的性能，另外无法继承原型链上的属性和方法

11.  组合继承是构造继承加原型继承

     优点：继承父级的构造函数和原型上的属性和方法

     缺点：调用了两次父级的构造函数有些许损耗性能，并且子级的构造，函数的属性会和原型上面的属性重合 

12.  原型式继承，不需要定义一个构造函数传入参数obj生成一个继承obj对象的对象 

13.  寄生式继承，即创建了一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后返回对象 

14.  寄生组合式继承是构造继承家寄生继承只调用一次父级构造函数，并且还能继承原型链上面的方法 

---



### 第十二章

# 标准内置对象（构造器） #

### 布尔类型

##### 

- undefined——>False

- null——>False

- 布尔值——>与输入相同

- 数字——>0、NaN 转换成false，其他数字转换成true

- 字符串——>''空字符串转换为false，其他字符串转换成true

- 对象——>总是true 

  

##### 手动转换为布尔值

- Boolean(value)  * 建议使用 *

- value ? true : false

- !! value

  

##### 假值

- undefined、null、false、0、NaN、‘ ’

##### 所有的对象都是真值

- new Boolean(false)、空对象、空数组也是真值

##### 二元逻辑运算符

（1）值保留：总是返回其中的一个运算数，且不改变它的值

> 'abc' || 123      ==>'abc'
>
> false || 123     ==>123

（2）短路：如果第一个运算数已经决定了结果，则不再求第二个运算数的值。

> true || console.log('Hello')    ==>true
>
> false || console.log('Hello')     ==>Hello

逻辑与（&&）：如果第一个运算数能被转换成false，则返回这个值。否则，返回第二个运算数

逻辑或（||）：如果第一个运算数能被转换成true，则返回这个值。否则，返回第二个远算数

##### 逻辑非（！）

逻辑非运算符会将它的运算数转换成布尔值，然后取反。

> ! true   ==>false
>
> ! 43    ==>false
>
> ! ''      ==>true
>
> ! {}     ==>false

##### Boolean函数的两种调用方式

1. Boolean(value)：作为一个普通函数，它将value转换成一个原始的布尔值

> Boolean(0)   ==>false
>
> typeof Boolean(false)   ==>'boolean'

2. new Boolean(bool)：作为一个构造函数，它会创建一个Boolean的实例

> typeof new Boolean(false)  ==>'object'



### 数字

##### 数字字面量

- 35、3.141、0xFF
- 指数eX，是10的x次方的缩写

##### 在字面量上调用方法

- 123..toString()
- 123 .toString()
- 123.0.toString()
- (123).toString()

##### 转换成数字

- undefined——>NaN
- null——>0
- 布尔值——>false转换成0，true转换成1
- 字符串——>解析字符串中的数字，空字符转换成0
- 对象——>调用ToPrimitive(value,number)并转换生成的原始类型

##### 手动转换为数字

Number(value) 、+value

##### parseFloat（）

全局函数parseFloat（）提供了另一种将值转换为数字的方法。

true==>NaN   null==>NaN    ' '==>NaN      '123.45#'==>123.45

parseFloat（）会一直解析到最后一个合法的字符，最后得到的可能不是想要的结果。

会忽略开头的空格，并且在非法的字符前停止，‘\t\v\r12.34\n’==>12.34

##### 特殊的数字值

- 两个错误值，NaN 和Infinity
- 两个零值，+0和-0

1. NaN:not a number

   产生NaN的操作：一个不能被解析的数字（‘xyz’）

   ​								失败的操作（Math.acos（2））

   ​								一个运算数是NaN（NaN+1）

   检查一个值是否是NaN:NaN是唯一一个和自身不相等的值

   ​										使用全局函数isNaN()

   ​										isNaN()对非数字不起作用

   > function myIsNaN(value){
   >
   > ​	return typeof value ==='number' && isNaN(value);
   >
   > }

2. Infinity：指出两种错误，一个大到无法表示的数字，或者除以了0

   Infinity比其他任意数字都大（除了NaN），-Infinity比其他任意数字都小（除了NaN）；

   2的1024次方不能被表示出来；

   Infinity的运算：如果尝试用一个Infinity“抵消”另一个Infinity，会得到错误的结果NaN

   检查Infinity：==和===

   ​						全局函数isFinite()可以检查一个值是否是实际的值

3. 区分两个0：根据Infinity和-Infinity   3/-0==>-Infinity  Math.pow(-0,-1)==>-Infinity

##### 数字的内部表示

前置百分号代表中间的数字采用二进制计数法编写：一个1，后面是一个二进制的点，跟着一个二进制的分数。

特殊的指数：1024给错误值用；-1023  =>0(如果分数是0)、接近0的很小的数字

##### 处理舍入错误

epsEqu()能确保常规比较不充分时结果是可靠的，

> epsEqu(0.1+0.2,0.3)   ==>true

##### 整型的范围

- 安全整型，JavaScript支持的最长的实用整型范围是：53位加一个符号

- 数组索引，32位，无符号，最大长度：2的32次方-1

- 按位运算符，无符号右移运算符（>>>）：32位，无符号

  ​						其他的所有按位运算符：32位，含一个符号

- “字符码”，UTF-16码以数字组成单元：可以被String.fromCharCode()接受；可以被String.prototype.charCodeAt()返回；16位，无符号

##### 安全的整型

一个安全的JavaScript整型指的是能够明确地表示一个单独的数学整数

检测一个整数是否安全的函数：Number.isSafeInteger（）

##### 转换成整数

1. Math函数：

   - Math.floor()将其参数转换成小于且最接近于它的整数
   - Math.ceil()将其参数转换成大于且最接近于它的整数
   - Math.round()将其参数转换成最接近于它的整数

2. 通过定制函数ToInteger()得到整数：移除浮点数的小数部分

3. 通过位运算符得到32位整数：二进制或or：ToInt32()移除了小数部分并且对2的32次方取模

   ​												   移位操作符



4. parseInt()函数：将字符串str解析成整数。该函数会忽略开头的空白字符并尽可能多的查找连续的合法数字
   - 基数：范围是”大于等于2，且小于等于36“，他决定了数字被解析时的基数。默认是10

##### 算术运算符

- -number：对参数取反
- +number：保持参数不变；非数字会被转换成数字
- 求余运算符（%）不是取模，求余操作符的结果通常和第一个操作数的符号相同，取模和第二个操作数的符号相同。

##### 二进制位运算符

位运算与：&   位运算或：|    位运算异或：^

##### 位运算移位操作符

<<左移   >>右移 （有符号）      >>>无符号右移

##### Number函数

- Number(value)：作为一个常规函数，他将value转换成一个原始数字
- new Number(num)：作为构造函数，创建了一个Number的实例

##### Number构造器属性

- Number.MAX_VALUE：可表示的最大整数
- Number.MIN_VALUE：可表示的最小正数值（一个非常小且大于0的分数）
- Number.NaN：和全局NaN相同的值
- Number.NEGATIVE_INFINITY：和-Infinity相同的值
- Number.POSITION_INFINITY：和Infinity相同的值

##### Number原型方法

- Number.prototype.toFixed（fractionDigits):返回不使用指数表示的数字，舍入到小数点后第fractionDigits位。默认是10，如果大于等于10的21次方，作用与toString()相同。
- Number.prototype.toPrecision(precision)：在使用类似toString()方法之前，将尾数精确到precision位。
- Number.prototype.toString(radix)：radix指定了显示数字的系统使用的基数
- Number.prototype.toExponential(fractionDigits)：强制使用指数标注来显示一个数字。

##### 用于数字的函数

- isFinite(number)：检查number是否为一个实际的数字
- isNaN(number)：如果number为NaN,返回true
- parseFloat(str)：将str转换成一个浮点数
- parseInt(str,radix)：将str解析成一个基为radix（2-36）的整数



### 字符串

##### 字符串字面量

单引号和双引号都可以表示字符串字面量

- 最常见的做法是在HTML中使用双引号，在JavaScript中使用单引号
- 在JSON中，必须使用双引号

##### 字符串字面量中的转义字符

1. 避免换行：通过反斜杠对行结束符进行转义，使一个字符串能够跨行拼写

   > var str = 'written \
   >
   > over \
   >
   > multiple \
   >
   > lines';
   >
   > console.log(str === 'written over multiple line');   //true2. 

2. 转义序列：转义序列以反斜杠开头

   - 控制字符：\b是空格符，\f是换页符，\n是换行符（新的一行），\r是回车符，\t是水平制表符，\v是垂直制表符
   - 代表自身含义的转义字符：\\'指单引号，\\"指双引号，\指反斜杠

3. NUL字符：该字符由\0表示

4. 十六进制转义序列：\xHH（HH是两个十六进制数字）通过ASCII码表示一个字符

   > '\x4D'   ==>'M'

5. Unicode转义序列：\uHHHH（HHHH是4个十六进制数字）表示一个UTF-16编码单元

   > '\u004D'       ==>'M'

##### 字符访问

- 'abc'.charAt(1)    ==>'b'
- 'abc'[1]    ==>'b'

##### 转换为字符串

- undefined ==>'undefined'
- null ==>'null'
- 布尔值==>false->'false',true->'true'
- 字符串==>输入即输出
- 对象==>调用ToPrimitive(value,String)并将原始值结果转换为字符串

##### 手动转换为字符串

- String(value)
- ''+value
- value.toString()
- 在展示数据时，JSON.stringify()要优于基本的字符串转换方法

##### 转换是不可逆的

> String(false)     ==>'false'
>
> Boolean('false')   ==>true

##### 字符串比较

1. 使用比较运算符<,>,===,<=,>=
   - 区分大小写
   - 不能很好的处理音符和重音符

2. 使用String.prototype.localeCompare(other)
   - 结果小于0表明待比较的字符串小于参数，结果大于0表明待比较的字符串大于参数

##### 字符串拼接

1. 合并：加号（+）运算符

   只要运算数中有一个是字符串，加号运算符就能完成字符串的拼接

   > var str = '';
   >
   > str +='Say hello';
   >
   > str += 7;
   >
   > str    ==>'Say hello 7'

2. 合并：拼接字符串数组

   将所有的字符串添加进一个数组，然后调用join方法将他们拼接起来

   > var arr = [];
   >
   > arr.push('Say hello');
   >
   > arr.push(7);
   >
   > arr.join(' ');  ==>'Say hello 7'

##### 字符串函数

1. String(value)：作为常规函数，将参数value转换为原始字符串值

   > String(123)  ==>'123'
   >
   > typeof String('abc')   ==>String

2. new String(str):String()作为构造函数会创建一个String的实例，其返回值是封装了str的一个对象

   > typeof new String('abc')   ==>'object'

##### 字符串构造器方法

- String.fromCharCode(codeUnit1,codeUnit2,.....)返回一个由UTF-16编码单元组成的字符串，其中每一个UTF-16编码对应一个无符号整数。

  > String.fromCharCode(97,98,99)   ==>'abc'

- 可以通过apply()方法将数字数组转换为字符串

  > String.fromCharCode.apply(null,[97,98,99])  ==>'abc'

- String.fromCharCode()是String.prototype.charCodeAt()的逆操作

##### 字符串length属性

属性length表示JavaScript字符串中字符的个数，且它是不可枚举的

##### 字符串原型方法

1. 提取子字符串

   - String.prototype.charAt(pos):该方法返回给定位置pos的字符

     > 'abc'.charAt(1)  ==>'b'

   - String.prototype.charCodeAt(pos):该方法返回给定位置pos的JavaScript字符对应的无符号整数

     > 'abc'.split(' ').map(function(x){ return x.charCodeAt(0)})   ==>[97,98,99]

   - String.prototype.slice(start,end?):该方法返回一个子字符串，他包括原字符串从start开始到end结束的所有字符（包括start，不包括end）。两个参数都可以为负数，此时会将参数与字符串的lenth属性相加

     > 'abc'.slice(2)    ==>'c'
     >
     > 'abc'.slice(1,2)   ==>'b'
     >
     > 'abc'.slice(-2)   ==>'bc'

   - String.prototype.substring(start,end?)：该方法可以替代slice()，可以处理负的位置参数且可以更好地跨浏览器兼容

   - String.prototype.split(separator?,limit?)：该方法通过separator指定的边界处将原字符串分割成子字符串，返回字符串组成的数组。该方法有两个参数，

     separator：可以为字符串或正则表达式。若未传入，将会把整个字符串封装在数组中返回

     limit：若传入，则返回的数组最多只能包含limit个元素

     > 'a,  b,c,  d'.split(/, */,2)   ==>['a','b']
     >
     > 'test'.split()     ==>['test']

     如果把空字符串用作分隔符，那么原字符串中的每个字符之间都会被分割并组成数组返回

2. 字符串的变换

   - String.prototype.concat(str1?,str2?...)：该方法返回由带拼接的字符串与str1、str2等参数拼接形成的新字符串

     > 'hello'.concat(' ','world','!')     ==>'hello world !'

   - String.prototype.toLowerCase()：该方法将原字符串中的字符转换为小写并返回

   - String.prototype.toLocaleLowerCase()：该方法的功能与toLowerCase()一样，但是转换时其遵循本地规则。

   - String.prototype.toUpperCase()：该方法将原字符串中的字符转换为大写并返回

   - String.prototype.toLocaleUpperrCase()：该方法的功能与toUpperCase()一样，但是转换时其遵循本地规则。

3. 字符串的检索和比较

   - String.prototype.indexOf(searchString,position?)：该方法从字符串的position位置（默认为0）开始检索，返回searchString在字符串中出现的位置，若未找到则返回-1

     > 'aXaX'.indexOf('X')   ==>1
     >
     > 'aXaX'.indexOf('X',2)   ==>3
     >
     > str.indexOf('abc')  >=0   等价于  /abc/.test(str)

   - String.prototype.lastIndexOf(searchString,position?):该方法从字符串的position位置（默认结尾位置）从后向前检索，返回searchString在字符串中出现的位置，若未找到返回-1

     > 'aXaX'.lastIndexOf('X')   ==>3
     >
     > 'aXaX'.lastIndexOf('X',2)   ==>1

   - String.prototype.localeCompare(other):该方法用本地特定的顺序对字符串和other进行比较。其返回值为数字

     字符串在字母表中排在other前面时返回值小于0

     字符串等于other时返回值等于0

     字符串在字母表中排在other后面时返回值大于0

     > 'apple'.localeCompare('banana')   ==>-2
     >
     > 'apple'.localeCompare('apply')  ==>0

4. 支持正则表达式的方法

   - String.prototype.search(regexp)：该方法返回字符串中第一个与regexp相匹配的子字符串的起始位置（若未匹配返回-1）

     > '-yy-xxx-y-'.search(/x+/)   ==>4

   - String.prototype.match(regexp)：该方法将regexp与字符串进行匹配。若regexp未设置全局标志/g则返回一个对象，它存放了第一次匹配相关的信息

     > '-abb-aaab-'.match(/(a+)b/)   ==>['ab','a',index:1,input:'-abb-aaab-']
     >
     > 设置了/g标志，则将所有匹配的子字符串存放在一个数组中返回
     >
     > '-abb-aaab-'.match(/(a+)b/g)    ==>['ab','aaab'] 

   - String.prototype.replace(search,replacement)：该方法检索与search匹配的字符串并用replacement替换。search可以是字符串或正则表达式，replacement可以是字符串或函数。除非search设置了/g标志的正则表达式，否则仅第一个匹配项会被替换

     > 'iixxxixx'.replace('i','o')   ==>'oixxxixx'
     >
     > 'iixxxixx'.replace('/i/','o')    ==>'oixxxixx'
     >
     > 'iixxxixx'.replace('/i/g','o')    ==>'ooxxxoxx'

     替换字符串中的$符号允许使用完全匹配或捕获分组进行替换

     > 'iixxxixx'.replace('/i+/g','($&)')    ==>'(ii)xxx(i)xx'
     >
     > 'iixxxixx'.replace('/(i+)/g','($1)')    ==>'(ii)xxx(i)xx'

     也可以通过函数进行替换

     > function repl(all){return '('+all.toUpperCase()+')'}
     >
     > 'axbbyyxaa'.repl(/a+|b+/g,replacement)
     >
     > '(A)xx(BB)yyx(AA)'



### 函数

##### JavaScript中函数的3种形式

1. 非方法函数（“普通函数”）

   可以直接调用函数，他会像一个普通函数一样运行

   通常，函数的命名以小写字母开头

2. 构造器

   通过new操作符来调用一个函数，这时候函数将是一个构造器，一个创建对象的工厂

   通常，函数作为构造器，其命名都以大写字母开头

3. 方法

   将一个函数存储为一个对象的属性，这时候他将变成一个方法，可以通过对象来调用它

   方法的名称也以小写字母开头

##### 形参和实参

形参被用在定义函数时，实参在函数调用时被使用

##### 定义函数

1. 函数表达式：函数表达式会产生一个对象——函数对象

   > var add = function(x,y){ return x+y};

   具名函数表达式：给函数表达式一个名字，具名的函数表达式一个名字，具名的函数表达式使得函数表达式可以引用他自己，这对递归很有用

   具名表达式的名字只能在函数表达式内部被访问

2. 函数声明：定义了一个新的变量，创建了一个函数对象，并将函数对象赋值给这个新的变量

   > function add(x,y){
   >
   > ​	return x+y;
   >
   > }

3. Function构造器：Function()构造器执行传给他的JavaScript代码字符串

   > var add  = new Function('x','y','return x+y');

##### 函数提升

函数提升表示将函数的声明放到作用域的开始。函数声明是做了完全提升的，而变量声明则是部分提升

由于函数声明是完全提升的，这允许你在函数声明前进行函数的调用

使用var定义也是会进行代码提升的，但是只对声明有效，对于赋值过程是无效的

##### 函数名称

大多数的JavaScript引擎对于函数对象都会提供一个非标准的name属性

- 函数的声明会创建这样的一个属性

  > function f1(){}
  >
  > f1.name   ==>'f1'

- 匿名函数表达式的name则是一个空字符串

- 具名函数表达式也有一个name

  > var f3 = function myName(){}
  >
  > f3.name   ==>'f3'

##### 函数声明和函数表达式

函数声明相比函数表达式有两个优势：

1. 函数声明会做代码提升，因此可以在源码中先于函数的定义来调用函数
2. 他们具有名字。不过JavaScript引擎也在对匿名函数表达式的名字引用做优化

##### 控制函数调用：call(),apply(),bind()

所有的函数都具有call(),apply(),bind()方法。他们可以在执行执行方法是用一个值指向this，并改变面向对象的作用域

1. func.apply(thisValue,argArray)

   在调用函数func时，argArray参数将作为函数的arguments传递给函数，thisValue可以指定执行func时的this值，在面向非对象的调用中是不必要的，设定为null

   apply()往往用在一个函数需要以类似数组（但又不是数组）的形式接受多个参数

   > Math.max.apply(null,[17,33,2])    ==>33

2. func.bind(thisValue,arg1,arg2....)

   这个方法会执行部分的函数功能，创建一个新的函数，这个函数调用func，会将thisValue指定为this。

##### 参数缺失或者超出时的处理

1. 实参数量多于形参：多余的参数是会被忽略的，但是能在类数组的arguments中被获取到
2. 实参数量少于形参：缺失的形参都会被赋予undefined的值

##### 通过索引访问所有参数：神奇的arguments变量

arguments变量只存在于函数中，他是一个类数组对象，包含了当前函数调用的所有实参

arguments的特征：

- 他是类数组，但又非数组，他有一个length属性，所有参数都可以通过索引值来进行读写；arguments不是一个数组，他没有数组的方法(slice(),forEach())
- 他是一个对象，支持所有的对象方法和操作。使用in操作符来检测arguments是否包含有指定索引位的参数

在严格模式下，禁用了arguments.callee指向了当前调用的函数和对变量arguments的分配，arguments在严格模式下不能实时变化

##### 强制性参数，限制参数数量的最小值

判断一个参数是否缺失：

1. 检测他是否为undefined
2. 将参数转化为布尔值，undefined会被认为false，但是还有一些假值会被认为是false
3. 用arguments.length来检测并强制指定参数数量的最小值

最后一种方式相比前两种有一些区别：前两种方式无法区分foo()和foo(undefined)，对于这两种情况会抛出一样的错误；第三种方式会对foo()抛错，而对于foo(undefined)会正常使用undefined传入函数并调用

##### 可选参数

处理可选参数：

1. 检测undefined
2. 将可选参数转换为布尔值
3. 使用或运算符，如果左侧操作数不是false值，则返回左侧的操作数，否则将返回右侧的操作数
4. 使用arguments.length来检测函数支持的最小数量的参数

前三种方式无法区分bar(1,2)和bar(1,2,undefined),这两种情况下optional的值都是默认值；第四种方式对于bar(1,2)会使用默认值，对于bar(1,2,undefined)会保留undefined的传入

还有一种处理可选参数的方式是使用具名参数，通过对象字面量的属性的方式

##### 模拟参数的引用传递

当你将一个变量传递给一个函数，它的值会被复制一份并传递给函数；在函数中，无法改变变量

##### 陷阱：非预期的可选参数

将一个函数c作为另一个函数f的参数传入

##### 具名参数

将实参和形参做映射的两种方式：

1. 通过位置来映射的位置型参数。第一个实参对应第一个形参
2. 具名参数则通过名称来做变量的映射。在一个函数的定义中名称会与形参做关联，在函数调用中，名称则与实参做关联。

具名参数的两个优点：对函数的参数进行了描述，同时他们对于处理可选参数的场景也很有用。

在JavaScript中模拟具名函数：通过对象字面量来命名参数，并将对象作为一个参数传入函数



### Date

##### Date构造函数

调用Date构造函数

1. new Date(year,month,date?,hours?,minutes?,seconds?,milliseconds?)：用给定的数据构造一个新的日期对象，这个时间与当时时区相对应。
2. new Date(dateTimeStr)：调用这个方法可以将日期时间字符串转换成数字，非法的日期时间字符串会将NaN传递给new Date(number)。
3. new Date(timeValue)：用1970年1月1日00:00:00以来创建一个日期，这个构造函数的逆运算是getTime()函数，他返回毫秒数。
4. new Date()：用当前的日期和时间创建一个日期对象；效果等同于new Date（Date.now())。

##### Date构造函数方法

1. Date.now()：该函数以毫秒为单位返回当前的日期和时间（从1970年1月1日00:00:00开始计算）
2. Date.parse(dateTimeString)：该函数将dateTimeString转换成毫秒，如果无法解析某字符串，便会返回NaN
3. Date.UTC(year,month,date?,hours?,minutes?,seconds?,milliseconds?)：将给定的日期转换成毫秒 。他跟接收同样参数的Date构造函数存在两点不同：他返回的是数值，而不是一个date对象；它将参数解释为UTC时间，而不是当地时间。

##### Date原型方法

getter和setter方法

1. Date.prototype.get《Unit》():根据当地时间返回时间单位
2. Date.prototype.set《Unit》(number)：根据当地时间设置单位时间 
3. Date.prototype.getUTC《Unit》()：根据世界时间返回单位时间
4. Date.prototype.setUTC《Unit》(number)：根据世界时间设置单位时间

### 第十三章

### 异常捕获

异常捕获的两个原则：如果一处出错的含义不能被描述，那么就抛错；找到一个可以捕获错误的位置，捕获异常。

##### throw

throw的语法：throw “value”；  可以抛出任何的JavaScript值

> if(somethingBadHappened) {
>
> ​	throw new Error('Something bad happened');
>
> }

#####  try-catch-finally

try是必须的，而catch和finally两者至少要有其一

- catch会捕获到try中抛出的任何的异常，无论是直接抛出的异常还是其中函数调用抛出的异常。

- 不论try中发生了什么，finally会永远执行，往往我们都会在finally里面做一些清理工作。

- finally在return语句之后执行

  > var count = 0;
  >
  > function countUp(){
  >
  > ​	try{
  >
  > ​			return count;
  >
  > ​	}finally{
  >
  > ​			count++;
  >
  > ​	}
  >
  > }
  >
  > countUp()    ==>0
  >
  > count     ==>1
  >
  > 在finally执行时，count的值已经被存入队列等待返回

#####  Error构造器

ECMAScript标准化了以下错误构造函数

- Error是通用异常构造器。所有其他的异常构造器都是它的子构造器
- EvalError “在标准中未使用，它只是为了兼容上一版本的标准”
- RangeError“表示一个数值超出了允许的范围。eg：new Array（-1）
- ReferenceError表示发现了一个非法的引用值
- SyntaxError表示产生了一个语法解析错误
- TypeError表示一个被操作值的实际类型与其期望的类型不一致
- URIError表示某个全局的URL控制函数的使用不兼容其定义

异常的属性值

- message：是异常的信息
- name：是异常的名称
- Stack：是栈跟踪，他不是标准的，但很多平台都在使用

#####  栈跟踪

通过栈跟踪，会创建异常对象的调用栈快照。 e.stack

### 数组

##### 数组是映射，不是元组

ECMAScript标准声明数组可以作为从索引到值的映射。数组可能不是连续的，中间可能会有空缺

#####  数组也可以具有属性

数组仍然是对象，并且可以拥有对象的属性。

#####  创建数组

1. 通过数组字面量创建数组

   > var myArray = ['a','b','c'];

2. 数组构造函数

   - 创建给定长度的空数组

     > var arr = new Array(2);

   - 用元素初始化数组（应该避免）

     > var arr1 = new Array('a','b','c');
     >
     > new Array(2)   ==>[,,]

##### 多维数组

如果需要多个维度的元素，必须嵌套数组 。

如果矩阵较小且维度固定，可以通过数组字面量来设置。

>  var rows = [['.','.',',','.'],['.','.','.'],['.','.','.','.']];

##### 数组索引

数组索引的限制：

- 索引i是数字，范围是0<=i<2的32次方-1
- 最大长度是2的32次方-1
- 在这个范围之外的索引被视为普通的属性键，他们不会作为数组元素呈现，且不影响length属性。

操作符in与索引：

操作符in检测对象是否具有某个给定键的属性，他也可以用来判断一个数组中是否存在给定的元素索引。

> var arr = ['a',,'b'];
>
> 0 in arr;    ==>true

删除数组元素：操作符delete，删除元素会产生空缺（不会更新length属性）

##### 长度

属性length的基本功能是追踪数组的最大索引，不计算元素的个数

属性length作为指针指向插入新元素的位置

**手动增加数组的长度**对数组几乎没有明显的影响，只会创建一些空缺

通过**Array构造函数**设置数组初始长度，创建的数组都是空的

如果**减少数组**的长度，在新长度及之后的所有元素都会被删除

**清空数组**：如果把数组的长度设置为0，则数组变为空，可以清空数组元素

把数组长度设置为0会影响共享词数组的对象，可以将数组赋值为空数组 

**数组的最大长度**是2的32次方-1

##### 数组中的“空缺”

索引个数小于数组长度说明数组缺少一些元素，在缺少元素的索引处读取该元素会返回undefined

##### 创建空缺

1. 通过给数组索引赋值来创建空缺

   > var arr = [];
   >
   > arr[0] = 'a';
   >
   > arr[2] = 'c';
   >
   > 1 in arr;    ==>false

2. 在数组字面量中省略值来创建空缺

   > var arr = ['a',,'c'];

##### 稀疏数组和密集数组

含有空缺的数组称为稀疏，不含空缺的数组称为密集。密集数组是连续的，且在每个索引处都存在元素

在相同索引处，空缺和undefined元素很相似，两个数组都有相同的长度；但稀疏数组在索引0处没有元素。

两个数组for遍历的结果相同；

forEach循环会跳过空缺，而不会跳过undefined元素

##### 忽略空缺

1. 数组遍历方法：

   - forEach()遍历时跳过空缺

     > ['a',,'b'].forEach(function(x,i){ console.log(i+'.'+x)})
     >
     > 0.a
     >
     > 2.b

   - every()也会跳过空缺

     > ['a',,'b'].every(function(x){ return typeof x=== 'string'})
     >
     > true

   - map()虽然会跳过，但保留空缺

     > ['a',,'b'].map(function(x,i){ console.log(i+'.'+x)})
     >
     > ['0.a','','2.b']

   - filter()去除了空缺

     > ['a',,'b'].filter(function(x){ return true})
     >
     > ['a','b']

2. 其他数组方法

   - join()把空缺、undefined和null转换为空字符串

     > ['a',,'b'].join('-')
     >
     > 'a--b'

   - sort()在排序时保留空缺

     > ['a',,'b'].sort();
     >
     > ['a','b',,]

3. for-in 循环可以正确的列出属性键

4. Function.prototype.apply():

   apply()把每个空缺转化成值为undefined的参数，可以用apply()创建包含undefined元素的数组

##### 数组构造函数

Array.isArray(obj):如果obj是一个数组，则返回true

#### 数组原型对象

##### 添加和删除元素——破坏性

1. Array.prototype.shift():删除索引0处的元素并返回该元素，随后元素的索引依次减1

2. Array.prototype.unshift(elem？……)：在数组最前面增加给定元素，返回新的数组长度

3. Array.prototype.pop()：移除数组最后的元素并返回该元素

4. Array.prototype.push(elem？……)：在数组尾部增加给定元素，返回新的数组长度

5. Array.prototype.splice(start，deleteCount？，elem？，……)：从索引start开始，移除deleteCount个元素，并插入给定的元素。

   特殊参数值：start可以是负数；deleteCount是可选的

##### 排序和颠倒元素顺序——破坏性

1. Array.prototype.reverse()：颠倒数组中的元素顺序，并返回指向原(修改后的)数组的引用
2. Array.prototype.sort(compareFunction?)：数组排序，并返回排序后的数组，排序是通过把元素转换为字符串再对值进行比较

- 比较数字

  > function compareCanonically(a,b){
  >
  > ​	return return a < b ? -1(a > b ? 1 :0);
  >
  > }
  >
  > [-1,-20,7,50].sort(compareCanonically)
  >
  > [-20,-1,7,50]

- 比较字符串

  > ['c','a','b'].sort(function(a,b){return a.localeCompare(b)})
  >
  > ['a','b','c']

- 比较对象

  > function compareNames(a,b){
  >
  > ​	return a.name.localeCompare(b.name);
  >
  > }// 根据名字进行排序

##### 合并、切分和连接——非破坏性

1. Array.prototype.concat(arr1?,arr2?,……)：创建一个新数组，其中包括接受者的所有元素，其次是数组arr1的所有元素；如果其中一个参数不是数组，它将作为元素添加到结果中.

   > var arr=['a','b'];
   >
   > arr.concat('c',['d','e']);
   >
   > ['a','b','c','d','e']

2. Array.prototype.slice(begin?,end?)：把数组从begin开始到end（不包含end）的元素复制到新数组中；如果任意一个索引值是负值，则该值加上数组长度，-1指向最后一个元素

3. Array.prototype.join(separator?)：通过对所有数组元素应用toString()创建字符串，并用separator连接字符串，默认使用‘，’连接。join()把undefined和null转换为空字符串，数组中的空缺也转化为空字符串。

##### 值的查找——非破坏性

1. Array.prototype.indexOf(searchValue,startIndex?)：从数组startIndex开始，查找searchValue，这个方法返回第一次出现searchValue的索引，没有找到返回-1。查找使用严格相等，不能用indexOf()查找NaN。
2. Array.prototype.lastIndexOf(searchElement,startIndex?)：反向查找

##### 迭代——非破坏性

- 检测方法
  1. Array.prototype.forEach(callback,thisValue?)：遍历数组中的元素，不支持break或者类似于提前终止循环的处理。
  2. Array.prototype.every(callback,thisValue?)：对每个元素，回调函数都返回true，则返回true。一旦回调函数返回false，则停止迭代。没有返回值会导致隐式返回undefined，every()解释为false
  3. Array.prototype.some(callback,thisValue?)：如果回调函数至少有一个元素返回true，则返回true。一旦回调函数返回true，则停止迭代。没有返回值会导致隐式返回undefined，some()解释为false

- 转换方法
  1. Array.prototype.filter(callback,thisValue?)：输出数组只包含callback返回为true的输入元素

- 规约方法 
  1. Array.prototype.reduce(callback,initialValue?)：从左到右进行迭代，并按照之前描述的调用回调函数。这个方法的结果是由回调函数返回的最后的值。
  2. Array.prototype.reduceRight(callback,initialValue?)：与reduce()工作原理相同，但从右到左遍历。

### 第十四章

### 正则表达式

##### 量词

- ？表示从未匹配或只匹配一次
- *表示匹配零次或多次
- +表示匹配一次或多次
- {n}表示完全匹配n次
- {n，}表示匹配n次或多次
- {n，m}表示匹配最少n次，最多匹配m次

##### 断言

断言，用来检测输入的当前位置

- ^只匹配输入的开始位置
- $只匹配输入结束位置
- \b只匹配单词的边界。不要与[\b]混淆，他匹配一个退格
- \B只匹配非单词边界
- (?=exp)：正向肯定断言：只匹配exp所匹配的接下来的内容。exp只是用来向前查找，但会忽略匹配的pattern部分
- (?!exp)：正向否定断言：只匹配exp不匹配的接下来的内容。exp只是用来向前查找，但会忽略匹配的pattern部分

##### 创建正则表达式

1. 字面量与构造函数

   字面量：/xyz/i  加载时编译

   构造函数（第二个参数是可选的） new RegExp('xyz','i')  运行时编译

   字面量在加载时编译，下面的代码求值时会产生异常：

   > function foo(){
   >
   > ​	/[/;
   >
   > }

   构造函数在调用时编译正则表达式。下面的代码不会导致异常，但调用foo()会导致异常

   > function foo(){
   >
   > ​	new RegExp('[');
   >
   > }

2. 标识

   标识是正则表达式字面量的后缀和正则表达式构造函数的参数；它修改正则表达式的匹配行为。

   g——global：给定的正则表达式可以匹配多次，他会影响几种方法，尤其是replace()

   i——ignoreCase：试图匹配给定的正则表达式时忽略大小写

   m——multiline：在多行模式时，开始操作符^和结束操作符$匹配每一行，而不是输入的整个字符串

##### RegExp.prototype.test:是否存在匹配

test()方法用来检查正则表达式regex是否匹配字符串str：regex.test(str)

test()根据是否设置/g标识，运行结果有所不同。如果没有设置/g标识，则该方法检查是否在str某处存在匹配；如果设置了/g标识，则该方法在str中会多次匹配regex并返回，属性regex.lastIndex包含最后一次匹配之后的索引。

##### String.prototype.search:匹配位置的索引

search()方法查找str匹配regex的位置：str.search(regex)

如果存在匹配，返回发现匹配位置的索引。否则，返回值-1。进行查找时，regex的global和lastIndex属性被忽略。如果search()的参数不是正则表达式，它被转换为正则表达式，search（）不支持全局检索。

##### RegExp.prototype.exec：捕获分组

首次分配（不设置标识/g），则只返回第一次的匹配结果

全部匹配（设置标识/g），会反复调用exec()返回所有的匹配项，返回值null表示没有任何匹配，属性lastIndex表示下次匹配从哪儿继续。

##### String.prototype.match：捕获分组或返回所有匹配的子字符串

var matchData = str.match(regex);

##### String.prototype.replace:查找和替换

replace()方法在字符串str中进行查找，匹配search并用replacement替换匹配项：str.replace（search，replacement）

search字符串或正则表达式，字符串：在输入字符串中找到匹配的字面量；正则表达式：对输入字符串进行匹配。

replacement字符串或函数，字符串：描述如何替换找到的匹配项；函数：执行替换并通过参数提供匹配信息。

##### 正则表达式备忘单

.（点）匹配除了行结束符（换行符、回车符等）的一切字符。使用[\s\S]可以真正匹配一切

- 转移字符类
  1. \d 匹配数字([0-9]);\D匹配非数字
  2. \w 匹配拉丁字母数字的字符以及下划线([A-Za-z0-9_])；\W匹配所有其他字符
  3. \s 匹配所有空白字符(空格、制表符、换行符等)；\S匹配所有非空白字符

- 字符类（字符集合）：[...]和[’^‘  ...]
  1. 源字符：[abc]  (除了\]-的所有匹配其本身的字符)
  2. 转义字符类：[\d\w]
  3. 范围：[A-Za-z0-9]

- 分组
  1. 捕获组：（...）；反向引用：\1
  2. 非捕获组：（？：...）

##### 直接量字符

字母和数字字符      匹配自身

\o     NUL字符（\u0000）

\t      制表符（\u0009）

\n     换行符 （\u000A）

\v      垂直制表符（\u000B）

\f       换页符（\u000C）

\r        回车符（\u000D）

\xnn    由十六进制nn指定的拉丁字符，\x0A等价于\n

\uxxx   由十六进制数xxxx指定的Unicode字符,例如\u0009等价于\t

\cX        控制字符^X，例如\cJ等价于换行符\n

##### 选择、分组和引用

子表达式分组和引用前一子表达式的特殊字符，字符“|”用于分隔供选择的字符。

eg：/ab|cd|ef/可以匹配ab、cd、ef；/\d{3}|[a-z]{4}/匹配三位数字或者四个小写字母。

圆括号的作用：①把单独的项组合成子表达式，以便可以向处理一个独立的单元那样用“|”“*”“+”“？”等来对单元内的项进行处理；②在完整的模式中定义子模式；③带圆括号的表达式的另一个用途是允许在同一正则表达式的后部引用前面的子表达式。

##### 修饰符

正则表达式的修饰符，用以说明高级匹配模式的规则，修饰符放在/之外，i用以说明模式匹配是不区分大小写的；g说明模式匹配应该是全局的；m用以在多行模式中执行匹配。

##### RegExp的属性

source：只读字符串，包含正则表达式的文本

global：是一个只读的布尔值，用以说明这个正则表达式是否带有修饰符g

ignoreCase：只读的布尔值，用以说明正则表达式是否带有修饰符i

multiline：只读的布尔值，用以说明正则表达式是否带有修饰符m

lastIndex：可读可写的整数，存储字符串中下一次检索的开始位置

### 第十五章

---

1. Math对象包含了一系列的数学运算的功能，Math对象不需要创建，直接使用 

2.   XML是指可扩展标记语言

     XML是一种标记语言

     XML的设计宗旨是传输数据而非显示数据

     XML被设计成为具有自我描述性

     XML被设计用来传输和存储数据,HTML被设计用来显示数据 

3.  XML书写准则文件的第1行必须是声明该文件是XML文件以及它所使用的XML规范版本

    在文件的前面不能够有其他元素或注释

    在文件中有且只能够有一个根元素 

    文件中大多用都是自定义的标记

    文件中用的标记必须正确的关闭，标记之间不得交叉

    属性值必须要用引号括起来

    控制标记指令和属性名称等英文要区分大小写

4.  json指的是js对象表示法，json是轻量级的文本数据交换格式，格式由道格拉斯提出，从js脚本语言中演变而来，json独立于语言和平台，更小更快更易解析是一种数据格式，不是编程语言 

5.   Json语法：

   - 并列的数据之间要用逗号分隔
   - 并列数据的集合数组用方括号表示
   - 映射用冒号表示
   - 映射的集合对象用大括号表示
   - 字符串必须加双引号 

6.  json语法可以表示以下三种类型的值

   - 简单值：与js语法相同，可以在json中表示字符串数值布尔值和null ，json不支持js中的特殊值undefined;

   - 对象，一种复杂的数据类型表示一组无序的键值对，键值对中的只可以是任意类型
   - 数组一种复杂的数据类型，表示一组有序的值的列表，数组的值也可以是任意类型 

7.   json是js对象的字符串形式的表示法，使用文本表示js对象的信息，本质是一个字符串 。

---



### 第十六章

---

1. Http是一种不保存状态即无状态协议，http协议自身对请求和享用之间的通信状态进行保存，也就是说在http这个级别，协议对于发送过的请求或响应都不做持久化处理。
2.  请求报文是由请求方法，请求URL,协议版本，可选的请求首部字段和内容实体构成的 。
3.  响应报文基本上有协议版本，状态码，表示请求成功或失败的数字代码，用于解释状态满的原因短语，可选择首部字段以及实体主体构成 。
4.  html 中form元素表示了文档中的一个区域，此区域包含有交互控制原件，用来向web服务器提交信息
   action 一个处理此表单信息的程序所在的url
   method:浏览器使用这种http方式来提交表单
   encype 将表单的内容提交给服务器的MIME类型 
5.  Ajax可以使用网页实现异步更新，这意味着可以在不更新加载整个网页的情况下，对网页的某部分进行更新
6.  Ajax是一种用来改善用户体验的技术，其实质就是使用XMLHttpRequest对象一步的向服务发送请求
   步骤:创建对象实例创建，请求发送，请求回调事件处理函数 
7.  readyState:表示XMLHttpRequest对象的状态
   onreadyatatechange:表示请求状态改变的事件触发器
   responseText:服务器响应的文本内容
   status:服务器返回的http状态码，200表示成功，404表示未找到，500表示服务器内部错误 
8.  open()指定和服务器端交互的http方法，url地址及其他请求信息 
9.  send()向服务器发出请求，如果采用异步方式方法会立即返回 
10.  setRequestHeader()设置http请求中的指定头部header的值为value,此方法需要在open方法以后调用，一般在post方式中使用 。
11.  同源策略是一种约定，它是浏览器最核心也是最基本的功能，同源策略是只限制不同源之间执行特定操作。同源是指域名协议端口都相同
12.  跨域并不是请求发不出去，请求能发出去，服务端能接收到请求并正常返回，结果只是结果被浏览器拦截了 
13.  通过表单的方式可以发起跨域请求，跨域是为了阻止用户读取到另一个域名下的内容，ajax可以获取享用浏览器认为这不安全，所以拦截的响应，但是表单并不会获取新的内容，所以可以发行跨域请求 。

---



### 第十七章

---

1.  事件绑定分为两种，一种是传统事件绑定(内联模型，脚本模型)，一种是现代事件绑定(DOM2级模型) 

2.  内联模型违反了内容与行为相分离的原则，尽量少用脚本模型实现了内容与行为相分离，但元素只能绑定一个监听函数的模型，实现了内容与行为相分离，元素可以绑定多个监听函数 

3.  事件三要素
   事件是被动触发的，并不是我们能主动加上去的元素，只要符合某种事件触发条件，事件就必定会触发，我们所谓加上去的是js对事件的处理函数。

4.  事件流描述从页面接收事件的顺序事件流，包括两种模式冒泡和捕获

5.  Js中的事件冒泡事件，按照从目标元素到根源上的顺序触发，stopPropagation()方法阻止时间冒泡。

6.  事件处理周期触发一个事件后，在html元素间进行传播过程。

   第1阶段事件的捕获，事件对象沿DOM树向下传播对向下传播

   第2阶段目标触发，执行事件监听函数，

   第三阶段事件冒泡事件沿DOM树向上传播 

7.  浏览器是多进程的，Browser进程，Plugin进程，GPU进程，Renderer进程 

8.  Js引擎线程是单线程，js的主要用途是用户互动以及操作dom,单线程，就意味着所有任务需要排队，前一个任务结束才会执行后一个任务。

9.  消息队列:消息队列是一个先进先出的队列，它里面存放着各种消息，任务。时间循环，事件循环是指主线程重复从消息队列中获取消息执行的过程 。

---



### 第十八章

---

1.   Js库封装了很多预定义的对象和使用函数，能帮助使用者轻松建立有难度交互的web2.0特性的客户端界面 ， 并且兼容各大浏览器 。

2.  jQuery是一个优秀的，轻量级的js库类，是由John Resig创建于2006年1月的开源项目 。

3.  jQuery的特点，轻量级强大的选择器，出色的DVD操作的封装，可靠的事件处理机制，出色的浏览器兼容性。

4.  jQuery核心理念是write less ,do more 。

5.  jQuery编程步骤:引入jQuery的js文件，使用选择器定位要操作的节点，调用jQuery的DOM方法进行操作 。

6.  jQuery 选择器语法
   $(selector).action()
    美元符号: 定义 jQuery 对象，等价于 jQuery 对象；选择符（selector）:“查询”和“查找” HTML 元素
    jQuery 的 action() 执行对元素的操作

   - 基本功能：快速、精确地选择某一个（某一组）元素；返回该元素（组）的 jQuery 包装集

7.  jQuery 对象和 DOM 对象转化：

   - DOM→jQuery：使用  $( )  包装

     >var divNode = document.getElementById(‘show’);
     >var div = $(divNode);

   -  jQuery→DOM：数组下标方式、get( )方法获得

     > var div = $(‘#show’);
     > var divNode = div.get(0);//或 var divNode = div[0];

8. 事件是指可以被 JavaScript 侦测到的行为; JavaScript 原生事件和 jQuery 中的事件是一致的，唯一不同是调用和处理事件的方式不同。

9. $(document).ready( ) 方法和 window.onload 事件功能相似，但是也有区别

   - 执行时机
      window.onload: 在网页中所有的元素完全加载到浏览器后执行
     $(document).ready( ): 在DOM完全加载以后就可以调用
   - 事件编写个数
      window.onload 事件不能同时编写多个
      $(document).ready( ) 方法能同时编写多个
   - 简化写法
      window.onload 事件没有简化写法
      $(document).ready( ) 方法有简化写法

10. 给对象添加事件方法
     $("selector") . on( EventName ，handler）
     $("selector") . EventName ( handler );

11. 移出事件方法
     $("selector") . off( events [, handler ]）

12. jQuery()异步请求：

    - $.post()

      >$.post(url,
      >       function (data) {//数据返回成功执行函数
      >            console.log(data)
      >       }
      >)

    - $.get( )  

    - > $.get(url,
      >        function (data) {//数据返回成功执行函数
      >             console.log(data)
      >        }
      > )

13. 隐藏和显示 —— show( ) 和 hide ( )方法

    滑动 —— slideUp( ) 和 slideDown( )方法

    切换 —— slideToggle( )方法

    淡入淡出 —— fadeIn( ) 和 fadeOut()方法

    切换 —— fadeToggle( )方法

    fadeTo( )方法把元素的不透明度以渐近的方式调整到指定的值

14. 自定义动画 —— animate(styles, speed ,callback)

    - styles  —— 包含样式属性及值得对象
    -  speed    —— 速度参数
    -  callback —— 回调函数，在动画完成时触发执行

15. 综合动画：当为同一组元素使用多重效果时，通过链式写法实现效果排队，只有数字值可以创建动画，字符串值无法创建动画。

---



### 第十九章

---

1.  let 声明变量：用于声明变量，用法与 var 类似；与 var 的不同在于，用 let 声明的变量只在 let 命令所在的代码块 { }内有效
2. let 声明的特点：禁止重复声明、不存在变量提升、 暂时性死区
3. const 命令：声明一个只读的常量。
4.  const 声明的特点：禁止重复声明、不存在变量提升、暂时性死区、变量不可修改、 声明后必须立刻赋值，否则会报错。
5.  解构赋值：
   - 解构赋值按照一定模式，将属性/值从对象/数组中取出，赋值给其他变量
   -  解构赋值属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值
   - 目的：简化提取信息任务 
6. 对象的解构赋值的机制是：先找到同名属性，然后再赋给对应的变量；解构不成功，变量的值赋值为 undefined。
7. 扩展运算符用三个点号表示，功能是把数组或类数组对象展开成一系列用逗号隔开的值。
8. rest运算符：定义一个 log 方法，让它可以代理 console.log 方法。rest 运算符也是三个点号，用于获取函数的多余参数，这样就不需要使用 arguments 对象。
9. 模板字符串：是增强版的字符串，用反引号（` `）标识；可以当作普通字符串使用，也可以用来定义多行字符串；可以在字符串中嵌入变量，需要将变量名写在${expression}之中
10. 箭头函数（是匿名函数）特点： 简洁的语法、不绑定 this、没有 arguments 对象。
11. Array.from ()方法用于将类似数组的对象转为真正的数组 ；Array.of() 方法用于将一组值，转换为数组。
12. Symbol 数据类型 
    - Symbol 值通过 Symbol 函数生成
    - Symbol 变量属于基本数据类型（不是对象），Symbol 函数前不能使用 new 命令
    - Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要用于区分变量
    - 相同参数的 Symbol 函数的返回值是不相等的
13. Symbol 值可以作为标识符，用于对象的属性名。
14.  Symbol.for（）接受一个字符串作为参数，然后搜索以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值， 如果没有，就新建并返回一个以该字符串为名称的 Symbol 值。
15.  for...of 遍历可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象、字符串； for...of 不能遍历普通 Object 对象； for...of 循环，允许遍历获得属性值。

16. Set 是一个构造函数，通过 new 生成 Set 数据结构实例；类似于数组，但是成员的值都是唯一的，没有重复的值。
17.  Map 是一个构造函数，通过 new 生成 Map 数据结构实例；类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键；Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应。
18. Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。
19. Promise 的优势：
    - 将异步操作以同步操作的流程表示出来，利于阅读和维护
    -  将数据请求和数据处理明确区分开，掌握控制权
20. Promise 是一个构造函数， new Promise 返回一个 promise 实例对象。
    构造函数接收一个 executor 函数作为参数，executor 函数参数有两个函数类型形参 resolve、 reject；
    Promise 构造函数执行时立即调用执行 executor 函数。
21. then() 方法返回一个  Promise，返回任意一个非 promise 的值都会被包裹成 promise 对象。
22. 宏任务/微任务执行顺序
    1.  执行一个宏任务
    2. 执行宏任务过程中如果遇到微任务，添加到微任务的任务队列中
    3. 一个宏任务执行完毕后，立即依次执行当前微任务列队中的所用微任务
    4.  循环上述过程直到任务列队中为空
23. ES6 的 class：
    - ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到
    - ES6 的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已
24. Class 和构造函数的区别
    - 类必须使用 new 调用，否则会报错
    -  类的内部，默认是严格模式
    -  类不存在变量提升，与 let 相似

